# ParaCL 

> **Интерпретатор языка Парасил** считывает со стандартного ввода всё, что считывается, и печатает на стандартный вывод всё, что нужно распечатать

 **Парасил** - простой СИ-подобный язык.
  
 ### Пример программ на парасиле
 ##### (если вводится в терминале, то чтобы завершить ввод, нужно
 ##### отправить Ctrl + C, Enter)
 

  ```
  fst = 0;
  snd = 1;
  iters = ?;

  while (iters-- > 0)
  {
    tmp = fst;
    snd = (fst = snd) + tmp;
  }

  print snd;

  ```

  ```
  y = 1;

  while (((x = ?)++)++ > y > 0)
  {
    print /*комментарий*/ y = x;
  }

  ```

 ### Синтаксис:

  1. ###### Все типы **int**

  2. ###### Программа состоит из *утверждений*:


  * Условный оператор **if**
  ```
  if(expression) 
  {
    ....
  }
  else
  {
    .... // либо сокращенная форма без {}
  }
  ```


  * Цикл **while**
  ```
  while(expression)
  {
    .... //  либо без  {}
  }
  ```


  * **Присваивание** арифметического выражения либо ввод с клавиатуры
  ```
  x = 1; // возвращают новое значение x
  x = ?; 
  ```


  * Постфиксные **инкремент** и **декремент**
  ```
  x++;  x--;   // возвращают новое значение x 
  ```


  * **Вывод** на экран
  ```
  print x; 
  ```


  3. ###### Комментарии
  ```
  // Однострочные   и 

  /*         много
     строчные      */
  ```


  4. ###### Приоритет операций
  ```
  1. ++, --
  2. -      // унарный
  3. * , /
  4. + , -
  5. > , <, >=, <=, ==, !=
  ```

-----------------------------------------------------------------------------

 ### Функции и области видимости в ParaCL


  1. ##### Области видимости

* Время жизни объекта ограничено его областью видимости
  ```
  {
    y = 1;
  }

  print y;
  ^C

  Uninitialized variable in current scope
  4 | print y ; 
    |        ^
    | Error in row number 4 and column number 2


  ```


* **Scopes** возвращают результат последнего expression внутри
  ```
  x = {
    y = 18;
    z = { print y; }
    y + z--;
  }; //  ; не обязательна

  print x; //x == 35
  ```


  2. ##### Функции также являются объектом

* Для введения функции:  **func**, имена аргументов, scope

Внутри функции можно обращаться только к переменным, объявленным как аргументы функции либо к локальным.

  ```
  summ = func(x, y)
  {
    x + y;
  }; // ; не  обязательна

  z = summ(1, 2); // z == 3
  ```


* Результат функции - результат последнего expression, либо явный **return**
  ```
  negate = func(x)
  {
    if (x < 0)
      return x;

    return -x;
  }

  y = 10;
  z = negate(y); // z == -10
  ```


* Возможно глобальное имя ( : fibb) , например, для рекурсии, которое видно из любого scope. Локальное имя (fibbonachi) видно только в scope объявления, либо ниже.
  ```
  fibbonachi = func(x) : fibb
  {
    res = 1;
    if (x > 1)
      res = fibb(x - 1) + fibb(x - 2);
    res;
  }

  x = fibbonachi(10); // x == 89
  ```


-----------------------------------------------------------------------------

 ### LLVM IR

* Программа на языке ParaCL может быть представлена в виде LLVM IR
* Например, для функции zero
  ```
    zero = func(x)
    {
      if (x)
        return 0;
      x;
    }
    print zero(1); //0
  ```
![example](zero.png)  


 
-----------------------------------------------------------------------------

 ### Сборка:  
 
 * В корневой директории:
```
  $cmake -B build
  $cd build/
  $make
```
 * Чтобы удалить объектные файлы в директории *build*:  
```
  $make clean
```

#### Интерпретация

 * Чтобы запустить *интерпретатор языка ParaCL* нужно в директории *build*(При таком запуске программа будет считана со стандартного ввода до сигнала Ctrl + C, Enter. Затем исполнена.):
``` 
  $./Interpreter   
``` 

 * Можно указать название файла с программой на языке ParaCL (например, если Program.txt в текущей директории) в агрументах командной строки:
```
 $./Interpreter  Program.txt
```

  * **При любом запуске дамп LLVM IR будет напечатан в файл "llvmIR.txt" в директории *build***

#### Генерация LLVM IR

 * Чтобы запустить *только генерацию LLVM IR* нужно в директории *build*(При таком запуске программа будет считана со стандартного ввода до сигнала Ctrl + C, Enter):
``` 
  $./Interpreter CODEGEN
``` 

 * Можно также указать название файла с программой на языке ParaCL (например, если Program.txt в текущей директории) в агрументах командной строки:
```
 $./Interpreter CODEGEN Program.txt  
```
 * **При явном указании CODEGEN программа не исполнится, дамп LLVM IR будет напечатан в файл "llvmIR.txt" в директории *build***


#### Тестирование

 * Чтобы запустить *тестирование языка ParaCL* нужно в *build/Tests* (будут запущены тесты на парасил из "ParaCL/Tests/tests/data" и на обработку ошибок из "ParaCL/Tests/input_tests/data", результаты будут на экране). Находясь в *build*:  
```
  $cd Tests/
  $./ParaCL_test

```

А так выглядит представление синтаксического дерева внутри программы:

![example](sintax_tree.png)
